#!/usr/bin/env python3
"""
Base TTS Engine Interface
Contains the abstract base class that all TTS engines must implement
"""

import logging
from abc import ABC, abstractmethod
from pathlib import Path
from typing import Any, Dict, List

from engines.core.types import EngineType, ConversionParams
from engines.models import Voice
from engines.utils.validation import validate_audio_file, ValidationConfig, AudioValidationResult

logger = logging.getLogger(__name__)


class BaseTTSEngine(ABC):
    """Abstract base class for all TTS engines with explicit parameters"""
    
    def __init__(self, name: str, engine_type: EngineType):
        self.name = name
        self.engine_type = engine_type
        self.is_available = False
        self.error_count = 0
        self.last_error = None
    
    @abstractmethod
    async def initialize(self) -> bool:
        """
        Initialize the engine and check availability
        
        Returns:
            bool: True if initialization successful, False otherwise
        """
        pass
    
    async def convert_text_to_speech(self, text: str, output_path: Path, params: ConversionParams) -> bool:
        """
        Convert text to speech and save to file (Template method with automatic validation)
        
        Args:
            text (str): Text content to convert
            output_path (Path): Output file path for audio
            params (ConversionParams): Explicit conversion parameters
            
        Returns:
            bool: True if conversion successful, False otherwise
        """
        try:
            # Delegate to engine-specific conversion logic
            conversion_success = await self._perform_conversion(text, output_path, params)
            
            if not conversion_success:
                return False
            
            # Automatically validate the generated audio
            validation_result = self.validate_audio_output(output_path)
            if not validation_result.is_valid:
                logger.error(f"{self.name}: Generated audio failed validation: {validation_result.errors}")
                # Audio was generated but is invalid - this is still considered a conversion failure
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"{self.name}: Conversion failed with exception: {e}")
            self.last_error = str(e)
            self.error_count += 1
            return False
    
    @abstractmethod
    async def _perform_conversion(self, text: str, output_path: Path, params: ConversionParams) -> bool:
        """
        Engine-specific conversion implementation (without validation)
        
        Args:
            text (str): Text content to convert
            output_path (Path): Output file path for audio
            params (ConversionParams): Explicit conversion parameters
            
        Returns:
            bool: True if conversion successful, False otherwise
        """
        pass
    
    @abstractmethod
    async def list_voices(self) -> List[Dict[str, Any]]:
        """
        List available voices for this engine
        
        Returns:
            List[Dict]: List of voice information dictionaries
        """
        pass
    
    @abstractmethod
    def parse_voice_list(self, raw_output: str) -> List[Voice]:
        """
        Parse raw CLI output into standardized Voice objects
        
        Args:
            raw_output (str): Raw CLI output from voice listing command
            
        Returns:
            List[Voice]: Parsed voice objects with standardized format
        """
        pass
    
    @abstractmethod
    def validate_params(self, params: ConversionParams) -> tuple[bool, str]:
        """
        Validate that this engine can handle the given parameters
        
        Args:
            params (ConversionParams): Parameters to validate
            
        Returns:
            tuple[bool, str]: (is_valid, error_message)
        """
        pass
    
    def validate_audio_output(self, output_path: Path, config: ValidationConfig = None) -> AudioValidationResult:
        """
        Validate the audio file generated by the engine
        
        Args:
            output_path (Path): Path to the generated audio file
            config (ValidationConfig): Validation configuration (uses defaults if None)
            
        Returns:
            AudioValidationResult: Detailed validation results
        """
        if config is None:
            # Use permissive defaults for TTS engines
            config = ValidationConfig(
                min_duration_seconds=0.1,  # At least 100ms of audio
                min_file_size_bytes=50,    # At least 50 bytes
                require_metadata=False     # Don't require metadata
            )
        
        try:
            result = validate_audio_file(output_path, config)
            
            # Log validation results
            if result.is_valid:
                logger.info(f"{self.name}: Audio validation passed for {output_path}")
                if result.duration_seconds:
                    logger.info(f"{self.name}: Generated {result.duration_seconds:.2f}s of audio")
            else:
                logger.warning(f"{self.name}: Audio validation failed for {output_path}")
                for error in result.errors:
                    logger.warning(f"{self.name}: Validation error - {error}")
            
            # Log warnings without failing validation
            for warning in result.warnings:
                logger.warning(f"{self.name}: Validation warning - {warning}")
                
            return result
            
        except Exception as e:
            logger.error(f"{self.name}: Audio validation failed with exception: {e}")
            # Return a failed validation result
            result = AudioValidationResult(
                is_valid=False,
                file_path=output_path,
                errors=[f"Validation exception: {e}"]
            )
            return result 